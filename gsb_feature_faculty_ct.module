<?php
/**
 * @file
 * Code for the gsb_feature_faculty_ct feature.
 */

include_once 'gsb_feature_faculty_ct.features.inc';

/**
 * Implements hook_form_FORM_ID_alter() for faculty node edit form.
 */
function gsb_feature_faculty_ct_form_faculty_node_form_alter(&$form, &$form_state) {

  $language = $form['language']['#value'];
	
  if (isset($form['field_conf_presentations_section'][$language])) {
    foreach ($form['field_conf_presentations_section'][$language] as $key => $value) {
      if (is_numeric($key)) {
        $form['field_conf_presentations_section'][$language][$key]['field_link_conf_pres_unlimited'][$language][0]['#title'] = '';
      }
    }
  }

  $form['field_leave_date']['#states'] = array(
    'required' => array(
      ':input[name="field_leave_status[' . $language . ']"]' => array('value' => '1'),
    ),
    'visible' => array(
      ':input[name="field_leave_status[' . $language . ']"]' => array('value' => '1'),
    ),    
  );

  $form['field_leave_statement']['#states'] = array(
    'required' => array(
      ':input[name="field_leave_status[' . $language . ']"]' => array('value' => '1'),
    ),
    'visible' => array(
      ':input[name="field_leave_status[' . $language . ']"]' => array('value' => '1'),
    ),    
  );

  $form['#validate'][] = 'gsb_feature_faculty_ct_form_faculty_node_validate';

}

function gsb_feature_faculty_ct_form_faculty_node_validate($form, &$form_state) {

  $language = $form['language']['#value'];

  if ($form_state['values']['field_leave_status'][$language][0]['value'] == 1) {

    if ($form_state['values']['field_leave_date'][$language][0]['value']  == null ||
        $form_state['values']['field_leave_date'][$language][0]['value2'] == null) {
      $errors = form_get_errors();
      if (empty($errors)) {
        form_set_error('field_leave_date', 'Please set a start and an end date for field On Leave');
      }
    }

    if ($form_state['values']['field_leave_statement'][$language][0]['value'] == '') {
      form_set_error('field_leave_statement', 'Leave Statement is required.');
    }

  } else {

    $leave_date_error_keys = array(
      'field_leave_date][und][0',
      'field_leave_date][und][0][value',
      'field_leave_date][und][0][value2',
    );

    $errors = form_get_errors();

    if ($errors) {

      // Clear errors.
      form_clear_error();

      // Clear error messages.
      $error_messages = drupal_get_messages('error');

      // Initialize an array where removed error messages are stored.
      $removed_messages = array();

      foreach ($errors as $name => $error_message) {
        if (in_array($name, $leave_date_error_keys)) {
          $removed_messages[] = $error_message;
          unset($errors[$name]);
        }
      }

      // Reinstate remaining errors.
      foreach ($errors as $name => $error) {
        form_set_error($name, $error);
        // form_set_error() calls drupal_set_message(), so we have to filter out
        // these from the error messages as well.
        $removed_messages[] = $error;
      }

      // Reinstate remaining error messages (which, at this point, are messages that
      // were originated outside of the validation process).
      foreach (array_diff($error_messages['error'], $removed_messages) as $message) {
        drupal_set_message($message, 'error');
      }

    }
  }

}

/**
 * Implements hook_node_view_alter
 */
function gsb_feature_faculty_ct_node_view_alter(&$build, $entity_type) {
  // Only show the leave statement if the node is being viewed 
  // between the leave dates.
  $wrapper = entity_metadata_wrapper($entity_type, $build["#$entity_type"]);
  if ($wrapper->getBundle() != 'faculty') {
    return;
  }
  $build['field_leave_statement']['#access'] = FALSE;
  $leave_date = $wrapper->field_leave_date->value();
  if ($leave_date != null && $wrapper->field_leave_status->value()) {
    $today = new DateTime();
    $start_date = new DateTime($leave_date['value']);
    $end_date = new DateTime($leave_date['value2']);
    if ($start_date <= $today &&  $today <= $end_date) {
      $build['field_leave_statement']['#access'] = TRUE;
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function gsb_feature_faculty_ct_node_presave($node) {
  if (isset($node->workbench_moderation_state_new)) {
    _gsb_feature_faculty_ct_update_academic_areas($node, $node->workbench_moderation_state_new);
    _gsb_feature_faculty_ct_update_faculty_by_sunet($node, $node->workbench_moderation_state_new);
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for workbench_moderation_moderate_form().
 */
function gsb_feature_faculty_ct_form_workbench_moderation_moderate_form_alter(&$form, &$form_state, $form_id) {
  // Add our submit function in front of workbench, since it will redirect and
  // prevent other submit functions from running.
  array_unshift($form['#submit'], 'gsb_feature_faculty_ct_workbench_moderation_moderate_form_submit');
}

/**
 * Form submission handler for workbench_moderation_moderate_form().
 */
function gsb_feature_faculty_ct_workbench_moderation_moderate_form_submit(&$form, &$form_state) {
  $node = node_load($form_state['values']['node']->nid, $form_state['values']['node']->vid);
  _gsb_feature_faculty_ct_update_academic_areas($node, $form_state['values']['state']);
  _gsb_feature_faculty_ct_update_faculty_by_sunet($node, $form_state['values']['state']);
}

/**
 * Updates the academic area via an external service.
 *
 * @param object $node
 *   The faculty node.
 * @param string $state
 *   The state of the node, e.g., 'draft', 'published'.
 */
function _gsb_feature_faculty_ct_update_academic_areas($node, $state) {

  if (!$service_url = variable_get('gsb_feature_faculty_ct_service_url', '')) {
    watchdog('gsb_feature_faculty_ct', 'No external service URL is set.');
    return;
  }
  // Only published faculty nodes should be updated.
  if ($node->type != 'faculty' || $state != workbench_moderation_state_published()) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);

  $query = array();
  // Pass the SUNet ID.
  $query['uid'] = $wrapper->field_sunetid->value();

  // Gather the secondary academic areas.
  $secondary_areas = array();
  foreach ($wrapper->field_academic_area_unlimited as $secondary_area) {
    $secondary_areas[] = _gsb_feature_faculty_ct_adjust_academic_area_names($secondary_area->label());
  }
  $query['secondaryAcadArea'] = implode('|', $secondary_areas);

  // Check for the primary academic area.
  if ($primary_area = $wrapper->field_academic_area_single->label()) {
    $query['primaryAcadArea'] = _gsb_feature_faculty_ct_adjust_academic_area_names($primary_area);
  }
  else {
    // Provide an invalid primary academic area to unset the value.
    $query['primaryAcadArea'] = 'none';
  }

  // Build the URL.
  $url = url($service_url . '/ManageAcademicAreas', array('query' => $query));
  $result = drupal_http_request($url);

  // Parse the result status.
  $xml = @simplexml_load_string($result->data);
  if ($result->code !== '200' || (string) $xml !== '1') {
    watchdog('gsb_feature_faculty_ct', 'Faculty update failed with status @status for user: @user', array('@user' => $query['uid'], '@status' => $result->code), WATCHDOG_WARNING);
  }
}

/**
 * Adjusts the academic area to match the destination value.
 *
 * @param string $name
 *   The academic area name.
 *
 * @return string
 *   The academic area name expected by the external service.
 */
function _gsb_feature_faculty_ct_adjust_academic_area_names($name) {
  $map = array(
    'Operations, Information & Technology' => 'Operations, Information and Technology',
  );
  if (isset($map[$name])) {
    $name = $map[$name];
  }
  return $name;
}

/**
 * Updates the faculty to copernicus via an external web service.
 *
 * @param object $node
 *   The faculty node.
 * @param string $state
 *   The state of the node, e.g., 'draft', 'published'.
 */
function _gsb_feature_faculty_ct_update_faculty_by_sunet($node, $state) {
  if (!$service_url = variable_get('gsb_feature_faculty_ct_service_url', '')) {
    watchdog('gsb_feature_faculty_ct', 'No external service URL is set.');
    return;
  }

  // Only published faculty nodes should be updated.
  if ($node->type != 'faculty' || $state != workbench_moderation_state_published()) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);

  $query = array();
  // Pass the SUNet ID.
  $query['sunet'] = $wrapper->field_sunetid->value();

  // Published status = 1 if published and 0 when it is un-published
  $query['bioPublished'] = $node->status;

  // Show email =0 if the field is empty 1 if it is not empty
  $email = $wrapper->field_email->value();
  $query['showEmail'] = 0;
  if (!empty($email)) {
    $query['showEmail'] = 1;
  }

  // Show phone =0 if the field is empty 1 if it is not empty
  $phone = $wrapper->field_phone->value();
  $query['showPhone'] = 0;
  if (!empty($phone)) {
    $query['showPhone'] = 1;
  }
  $query['rank'] = $wrapper->field_rank->value();

  // Build the URL.
  $url = url($service_url . '/UpdateFacultyBySunet', array('query' => $query));
  $result = drupal_http_request($url);

  // Parse the result status.
  $xml = @simplexml_load_string($result->data);
  if ($result->code !== '200' || (string) $xml !== '1') {
    watchdog('gsb_feature_faculty_ct', 'Faculty update failed with status @status for sunet: @sunet', array('@sunet' => $query['sunet'], '@status' => $result->code), WATCHDOG_WARNING);
  }
}

/**
 * Provides a _to_arg callback for faculty nodes.
 */
if (!function_exists('node_to_arg')) {
  function node_to_arg($arg) {
    static $result;
    if (!$result && (empty($arg) || $arg == '%')) {
      // If the user is anonymous, don't look anything up.
      if (user_is_anonymous()) {
        $result = $arg;
      }
      // Look for a sunetid field on faculty nodes that matches the user name.
      elseif (field_info_instance('node', 'field_sunetid', 'faculty')) {
        $query = new EntityFieldQuery('node');
        $results = $query
          ->entityCondition('bundle', 'faculty')
          ->fieldCondition('field_sunetid', 'value', $GLOBALS['user']->name)
          ->execute();
        if (!empty($results['node'])) {
          $result = key($results['node']);
        }
      }
      $arg = $result;
    }
    return $arg;
  }
}
